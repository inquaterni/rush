// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: packet.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#ifndef CAPNP_VERSION
#error "CAPNP_VERSION is not defined, is capnp/generated-header-support.h missing?"
#elif CAPNP_VERSION != 1002000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(b882bf8d67440a5d);
enum class PacketType_b882bf8d67440a5d: uint16_t {
  HANDSHAKE_CLIENT,
  HANDSHAKE_SERVER,
  RAW,
  COMPRESSED_ZSTD,
  ENCRYPTED_CHACHA20_POLY1305,
};
CAPNP_DECLARE_ENUM(PacketType, b882bf8d67440a5d);
CAPNP_DECLARE_SCHEMA(f40511d6c1828f99);
CAPNP_DECLARE_SCHEMA(8ef8bb12737a2c6c);
CAPNP_DECLARE_SCHEMA(c7d91fd9d12c18d9);

}  // namespace schemas
}  // namespace capnp


typedef ::capnp::schemas::PacketType_b882bf8d67440a5d PacketType;

struct Packet {
  Packet() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Body;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f40511d6c1828f99, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Packet::Body {
  Body() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    HANDSHAKE_CLIENT,
    HANDSHAKE_SERVER,
    GENERIC,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8ef8bb12737a2c6c, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Handshake {
  Handshake() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c7d91fd9d12c18d9, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class Packet::Reader {
public:
  typedef Packet Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::PacketType getType() const;

  inline typename Body::Reader getBody() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Packet::Builder {
public:
  typedef Packet Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::PacketType getType();
  inline void setType( ::PacketType value);

  inline typename Body::Builder getBody();
  inline typename Body::Builder initBody();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Packet::Pipeline {
public:
  typedef Packet Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename Body::Pipeline getBody();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Packet::Body::Reader {
public:
  typedef Body Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isHandshakeClient() const;
  inline bool hasHandshakeClient() const;
  inline  ::Handshake::Reader getHandshakeClient() const;

  inline bool isHandshakeServer() const;
  inline bool hasHandshakeServer() const;
  inline  ::Handshake::Reader getHandshakeServer() const;

  inline bool isGeneric() const;
  inline bool hasGeneric() const;
  inline  ::capnp::Data::Reader getGeneric() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Packet::Body::Builder {
public:
  typedef Body Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isHandshakeClient();
  inline bool hasHandshakeClient();
  inline  ::Handshake::Builder getHandshakeClient();
  inline void setHandshakeClient( ::Handshake::Reader value);
  inline  ::Handshake::Builder initHandshakeClient();
  inline void adoptHandshakeClient(::capnp::Orphan< ::Handshake>&& value);
  inline ::capnp::Orphan< ::Handshake> disownHandshakeClient();

  inline bool isHandshakeServer();
  inline bool hasHandshakeServer();
  inline  ::Handshake::Builder getHandshakeServer();
  inline void setHandshakeServer( ::Handshake::Reader value);
  inline  ::Handshake::Builder initHandshakeServer();
  inline void adoptHandshakeServer(::capnp::Orphan< ::Handshake>&& value);
  inline ::capnp::Orphan< ::Handshake> disownHandshakeServer();

  inline bool isGeneric();
  inline bool hasGeneric();
  inline  ::capnp::Data::Builder getGeneric();
  inline void setGeneric( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initGeneric(unsigned int size);
  inline void adoptGeneric(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownGeneric();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Packet::Body::Pipeline {
public:
  typedef Body Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Handshake::Reader {
public:
  typedef Handshake Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPublicKey() const;
  inline  ::capnp::Data::Reader getPublicKey() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Handshake::Builder {
public:
  typedef Handshake Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPublicKey();
  inline  ::capnp::Data::Builder getPublicKey();
  inline void setPublicKey( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initPublicKey(unsigned int size);
  inline void adoptPublicKey(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownPublicKey();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Handshake::Pipeline {
public:
  typedef Handshake Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::PacketType Packet::Reader::getType() const {
  return _reader.getDataField< ::PacketType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::PacketType Packet::Builder::getType() {
  return _builder.getDataField< ::PacketType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Packet::Builder::setType( ::PacketType value) {
  _builder.setDataField< ::PacketType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline typename Packet::Body::Reader Packet::Reader::getBody() const {
  return typename Packet::Body::Reader(_reader);
}
inline typename Packet::Body::Builder Packet::Builder::getBody() {
  return typename Packet::Body::Builder(_builder);
}
#if !CAPNP_LITE
inline typename Packet::Body::Pipeline Packet::Pipeline::getBody() {
  return typename Packet::Body::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename Packet::Body::Builder Packet::Builder::initBody() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  return typename Packet::Body::Builder(_builder);
}
inline  ::Packet::Body::Which Packet::Body::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline  ::Packet::Body::Which Packet::Body::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline bool Packet::Body::Reader::isHandshakeClient() const {
  return which() == Packet::Body::HANDSHAKE_CLIENT;
}
inline bool Packet::Body::Builder::isHandshakeClient() {
  return which() == Packet::Body::HANDSHAKE_CLIENT;
}
inline bool Packet::Body::Reader::hasHandshakeClient() const {
  if (which() != Packet::Body::HANDSHAKE_CLIENT) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Packet::Body::Builder::hasHandshakeClient() {
  if (which() != Packet::Body::HANDSHAKE_CLIENT) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Handshake::Reader Packet::Body::Reader::getHandshakeClient() const {
  KJ_IREQUIRE((which() == Packet::Body::HANDSHAKE_CLIENT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Handshake>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Handshake::Builder Packet::Body::Builder::getHandshakeClient() {
  KJ_IREQUIRE((which() == Packet::Body::HANDSHAKE_CLIENT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Handshake>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Packet::Body::Builder::setHandshakeClient( ::Handshake::Reader value) {
  _builder.setDataField<Packet::Body::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Packet::Body::HANDSHAKE_CLIENT);
  ::capnp::_::PointerHelpers< ::Handshake>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Handshake::Builder Packet::Body::Builder::initHandshakeClient() {
  _builder.setDataField<Packet::Body::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Packet::Body::HANDSHAKE_CLIENT);
  return ::capnp::_::PointerHelpers< ::Handshake>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Packet::Body::Builder::adoptHandshakeClient(
    ::capnp::Orphan< ::Handshake>&& value) {
  _builder.setDataField<Packet::Body::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Packet::Body::HANDSHAKE_CLIENT);
  ::capnp::_::PointerHelpers< ::Handshake>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Handshake> Packet::Body::Builder::disownHandshakeClient() {
  KJ_IREQUIRE((which() == Packet::Body::HANDSHAKE_CLIENT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Handshake>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Packet::Body::Reader::isHandshakeServer() const {
  return which() == Packet::Body::HANDSHAKE_SERVER;
}
inline bool Packet::Body::Builder::isHandshakeServer() {
  return which() == Packet::Body::HANDSHAKE_SERVER;
}
inline bool Packet::Body::Reader::hasHandshakeServer() const {
  if (which() != Packet::Body::HANDSHAKE_SERVER) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Packet::Body::Builder::hasHandshakeServer() {
  if (which() != Packet::Body::HANDSHAKE_SERVER) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Handshake::Reader Packet::Body::Reader::getHandshakeServer() const {
  KJ_IREQUIRE((which() == Packet::Body::HANDSHAKE_SERVER),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Handshake>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Handshake::Builder Packet::Body::Builder::getHandshakeServer() {
  KJ_IREQUIRE((which() == Packet::Body::HANDSHAKE_SERVER),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Handshake>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Packet::Body::Builder::setHandshakeServer( ::Handshake::Reader value) {
  _builder.setDataField<Packet::Body::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Packet::Body::HANDSHAKE_SERVER);
  ::capnp::_::PointerHelpers< ::Handshake>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Handshake::Builder Packet::Body::Builder::initHandshakeServer() {
  _builder.setDataField<Packet::Body::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Packet::Body::HANDSHAKE_SERVER);
  return ::capnp::_::PointerHelpers< ::Handshake>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Packet::Body::Builder::adoptHandshakeServer(
    ::capnp::Orphan< ::Handshake>&& value) {
  _builder.setDataField<Packet::Body::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Packet::Body::HANDSHAKE_SERVER);
  ::capnp::_::PointerHelpers< ::Handshake>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Handshake> Packet::Body::Builder::disownHandshakeServer() {
  KJ_IREQUIRE((which() == Packet::Body::HANDSHAKE_SERVER),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Handshake>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Packet::Body::Reader::isGeneric() const {
  return which() == Packet::Body::GENERIC;
}
inline bool Packet::Body::Builder::isGeneric() {
  return which() == Packet::Body::GENERIC;
}
inline bool Packet::Body::Reader::hasGeneric() const {
  if (which() != Packet::Body::GENERIC) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Packet::Body::Builder::hasGeneric() {
  if (which() != Packet::Body::GENERIC) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader Packet::Body::Reader::getGeneric() const {
  KJ_IREQUIRE((which() == Packet::Body::GENERIC),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder Packet::Body::Builder::getGeneric() {
  KJ_IREQUIRE((which() == Packet::Body::GENERIC),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Packet::Body::Builder::setGeneric( ::capnp::Data::Reader value) {
  _builder.setDataField<Packet::Body::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Packet::Body::GENERIC);
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder Packet::Body::Builder::initGeneric(unsigned int size) {
  _builder.setDataField<Packet::Body::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Packet::Body::GENERIC);
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Packet::Body::Builder::adoptGeneric(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  _builder.setDataField<Packet::Body::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Packet::Body::GENERIC);
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> Packet::Body::Builder::disownGeneric() {
  KJ_IREQUIRE((which() == Packet::Body::GENERIC),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Handshake::Reader::hasPublicKey() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Handshake::Builder::hasPublicKey() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader Handshake::Reader::getPublicKey() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder Handshake::Builder::getPublicKey() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Handshake::Builder::setPublicKey( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder Handshake::Builder::initPublicKey(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Handshake::Builder::adoptPublicKey(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> Handshake::Builder::disownPublicKey() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}


CAPNP_END_HEADER

